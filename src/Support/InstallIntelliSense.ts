import fs from 'fs';

export class InstallIntelliSense {
  public static readonly dts: string = `
class Logger{protected tool:Tool;constructor(tool:Tool);log(value:any):void;}interface ResultInterface{output():any|[any];isEmpty():boolean;}class ServicePayloadData{entity_id:string|null;setData(this:Record<string,any>,data:Record<string,any>):void;}class ServicePayload{domain:string|null;service:string|null;data:ServicePayloadData;}type Constructor<T>=new(value:number)=>T;class Enum{readonly value:number;constructor(value:number);static from<T>(this:Constructor<T>,value:number):T;get key():string;get data():Record<string,any>;is(enumObject:Enum):boolean;isAny(...enumObjects:Enum[]):boolean;}class CallServicePayload{readonly payload:ServicePayload;getDomain():string|null;setDomain(domain:string):this;getService():string|null;setService(service:string|Enum):this;getEntityId():string|null;setEntityId(entityId:string):this;setData(data:Record<string,any>):this;}class CallMultipleServicesOutput implements ResultInterface{readonly payloads:CallServicePayload[];createPayload(cb:(callServicePayload:CallServicePayload)=>void):this;pushPayload(callServicePayload:CallServicePayload):this;output():[any];isEmpty():boolean;}class CallServiceOutput extends CallServicePayload implements ResultInterface{output():any;isEmpty():boolean;}class OutputFactory{callService(cb?:(callService:CallServiceOutput)=>void):CallServiceOutput;callMultipleServices(cb?:(callMultipleServices:CallMultipleServicesOutput)=>void):CallMultipleServicesOutput;}abstract class ServiceEnum extends Enum{abstract get data():{title:string|null;state:string|null;};}type callback=(callService:CallServiceOutput)=>void;class Entity{private tool;readonly key:string;readonly entityId:string;readonly state:any;readonly attributes:any;readonly context:{id:string;parent_id:number|null;user_id:number|null;};readonly lastChanged:Date;readonly lastUpdated:Date;constructor(entityData:any);setTool(tool:Tool):this;exists():boolean;callService(cb?:string|ServiceEnum|callback):CallServiceOutput|null;}class Entities{protected tool:Tool;private readonly nrptPath;constructor(tool:Tool);isLoaded():boolean;all():Collection<Record<string,any>>;private createEntity;getEntity(entityId:string,key?:string,fallback?:any):Entity;getEntities(entityIds:[]|object,throwOnEmpty?:boolean):Collection<Entity>;getEntitiesByDomain(domain:string):Collection<Entity>;getEntitiesByDomainExcept(domain:string,entityIds:object|[]):Collection<Entity>;getLatestEntity(cb:string|((item:any)=>number),entityIds:[]|object,throwOnEmpty?:boolean):Entity;getEntityState(entityId:string,fallback?:any):any;logEntityData(entityId:string):void;logEntityDataFor(entityIds:[]|object):void;}class Time{isTimeInRange(stringTime:string,rangeInMinutes:number):boolean;}class Helper{Time:Time;}class Tool{readonly nodeRed:any;static toolClasses:{logger:typeof Logger;output:typeof OutputFactory;entities:typeof Entities;helpers:typeof Helper;};readonly logger:Logger;readonly output:OutputFactory;readonly entities:Entities;readonly helpers:Helper;constructor(nodeRed:any);}function create(nodeRed:any):Tool;class InstallIntelliSense{static readonly dts:string;static install():void;protected static createBackup(filePath:string):void;}class Switch extends ServiceEnum{static readonly TURN_ON:Switch;static readonly TURN_OFF:Switch;static readonly TOGGLE:Switch;get data():{title:string|null;state:string|null;};}class Light extends ServiceEnum{static readonly TURN_ON:Light;static readonly TURN_OFF:Light;static readonly TOGGLE:Light;get data():{title:string|null;state:string|null;};}class MotionBlind extends Enum{static readonly SET_ABSOLUTE_POSITION:MotionBlind;get data():{title:string|null;};}namespace Enums{{Enum};namespace Service{{Switch};{Light};{MotionBlind};}}{};class Collection<Item>{constructor(collection?:Item[]|Object);all():Item[];average<K>(key?:keyof Item|K):number;avg<K>(key?:keyof Item|K):number;chunk(size:number):Collection<Item[]>;collapse():Collection<Item>;combine<T,U>(array:U[]):Collection<T>;concat<T>(collectionOrArrayOrObject:Collection<T>|T[]|object):any;contains<K,V>(key:keyof Item|K|Function,value?:V):boolean;count():number;crossJoin<T>(values:T[]):Collection<[Item,T]>;dd():void;diff<T>(values:T[]|Collection<Item>):Collection<Item>;diffAssoc<T>(values:T[]|Collection<T>):Collection<Item>;diffKeys<K extends keyof Item>(object:object):Collection<K>;dump():this;each(fn:(currentItem:Item,key?:string|number,collection?:Item[])=>void):this;every(fn:(item:Item)=>boolean):boolean;except<K>(properties:K[]):Collection<Item>;filter(fn:(item:Item)=>boolean):Collection<Item>;filter(fn:(item:Item,key?:any)=>boolean):Collection<Item>;first<V>(fn?:(item:Item,key:any)=>boolean,defaultValue?:((...any:any[])=>V|Item)|V|Item):Item;flatMap<T>(fn:(item:Item,key:any)=>T):Collection<T>;flatten(depth?:number):Collection<Item>;flip():Collection<Item>;forget<K>(key:keyof Item|K):this;forPage(page:number,chunk:number):Collection<Item>;get<K,V>(key:keyof Item|K,defaultValue?:((...any:any[])=>V|Item)|V|Item):Item|null;groupBy<T,K>(key:((item:Item,index?:number)=>K)|keyof Item|K):Collection<T>;has<K>(key:keyof Item|K|(keyof Item)[]):boolean;implode<K>(key:keyof Item|K,glue?:string):string;intersect(values:Item[]|Collection<Item>):Collection<Item>;intersectByKeys<K extends keyof Item>(values:Item|Collection<Item>):Collection<K>
isEmpty():boolean;isNotEmpty():boolean;keyBy<T,K>(key:keyof Item|K|Function):Collection<T>;keys():Collection<string>;last(fn?:(item:Item)=>boolean):Item;macro(name:string,fn:Function):void;map<T>(fn:(item:Item,index:any)=>T):Collection<T>;mapInto<T extends Function>(ClassName:T):Collection<T>;mapToGroups(fn:Function):Collection<any>;mapWithKeys<T>(fn:Function):Collection<T>;max(key?:keyof Item|string):number;median<K>(key?:keyof Item|K):Item;merge<T>(objectOrArray:object|T[]):Collection<T>;min<K>(key?:keyof Item|K):number;mode<K>(key?:keyof Item|K):Collection<Item>|null;nth(n:number,offset?:number):Collection<Item>;only<K>(properties:K[]):Collection<Item>;partition(fn:(item:Item)=>boolean):[Item[],Item[]];pipe<U>(fn:(...any:any[])=>U):U;pluck<T,K,V>(value:keyof Item|V,key?:keyof Item|K):Collection<T>;pop():Item;prepend<K,V>(value:V,key?:K):this;pull<K>(key:keyof Item|K):Item|null;push(item:Item):this;put<K,V>(key:K,value:V):this;random(length?:number):this|Item;reduce<T>(fn:(_carry:T|null,item:Item)=>T,carry?:T):any;reject(fn:(item:Item)=>boolean):Collection<Item>;reverse():Collection<Item>;search(valueOrFunction:Item|((value:Item,key:number)=>boolean),strict?:boolean):any;shift():Item;shuffle():this;slice(remove:number,limit?:number):Collection<Item>;sort(fn?:(a:Item,b:Item)=>number):Collection<Item>;sortBy<V>(value:V):Collection<Item>;sortBy(fn:(item:Item)=>number):Collection<Item>;sortByDesc<V>(value:V):Collection<Item>;sortByDesc(fn:(item:Item)=>number):Collection<Item>;splice(index:number,limit:number,replace?:Item[]):Collection<Item>;split(numberOfGroups:number):Item[];sum<K>(key?:keyof Item|K|((item:Item)=>number|string)):number|string;[Symbol.iterator]:()=>Iterator<Item>;take(length:number):Collection<Item>;tap(fn:(collection:Collection<Item>)=>void):this;times<T>(times:number,fn:(time:number)=>T):T[];toArray<T>():T[];toJson():string;transform<T>(fn:(item:Item)=>T):Collection<T>;union<T>(object:Object):Collection<T>;unique<K>(key?:keyof Item|K|Function):Collection<Item>;unless(value:boolean,fn:(this:any)=>any,defaultFn:(this:any)=>any):void;unwrap<T>(value:T[]|Collection<T>):T[];values<T>():Collection<T>;when(condition:boolean,fn:(this:any)=>any,defaultFn:(this:any)=>any):void;where<K,V>(key:keyof Item|K,value:V):Collection<Item>;where<K,V>(key:keyof Item|K,operator:Operator,value:V):Collection<Item>;whereIn<K,V>(key:keyof Item|K,values:V[]):Collection<Item>;whereNotIn<K,V>(key:keyof Item|K,values:V[]):Collection<Item>;wrap<T>(value:T|T[]|Collection<T>):Collection<T>;zip<T>(array:T[]):Collection<[Item,T]>;getByKey(key:string,fallback?:any):any|Entity;[macroFn:string]:Function;}declare const Tools={Tool,Enums:{Enum,Service:{Switch,Lights,MotionBlind,},},create,InstallIntelliSense,collect}declare const NodeRedProgrammingTools=Tools;
`;

  public static install(): void {
    const funcDtsPath = './node_modules/@node-red/editor-client/public/types/node-red/func.d.ts';
    this.createBackup(funcDtsPath);
    const fileContents = fs.readFileSync(funcDtsPath).toString();
    const prefix = `
//=================== Node-Red Programming Tools ===================
`;
    if (!fileContents.includes(prefix)) {
      fs.writeFileSync(funcDtsPath, fileContents + prefix + this.dts);
    }
  }

  protected static createBackup(filePath: string): void {
    fs.copyFileSync(filePath, filePath + '.bak');
  }
}
